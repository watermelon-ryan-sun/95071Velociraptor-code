diff --git a/include/auton.h b/include/auton.h
index e8ee65a..583947e 100644
--- a/include/auton.h
+++ b/include/auton.h
@@ -6,4 +6,5 @@ void blueRightAWP();
 void blueLeftAWP();
 void blueSRightAWP();
 void skills();
+void specialOdomSkills();
 #endif
\ No newline at end of file
diff --git a/include/main.h b/include/main.h
index 288056e..4241bd2 100644
--- a/include/main.h
+++ b/include/main.h
@@ -62,6 +62,8 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
+extern volatile double XPos;
+extern volatile double YPos;
 void autonomous(void);
 void initialize(void);
 void disabled(void);
diff --git a/include/odom.h b/include/odom.h
index 802159f..456bacb 100644
--- a/include/odom.h
+++ b/include/odom.h
@@ -4,4 +4,5 @@
 static double lastTheta = 0;
 void recordPosition();
 void testThread();
+void movePosition(double targetX, double targetY, bool faceBack);
 #endif // _PROS_ODOM_H_
\ No newline at end of file
diff --git a/src/PIDControls.cpp b/src/PIDControls.cpp
index 3ab307d..bf41a5c 100644
--- a/src/PIDControls.cpp
+++ b/src/PIDControls.cpp
@@ -9,8 +9,6 @@ void tareMotors() {
    RM_MOTOR.tare_position();
    RF_MOTOR.tare_position();
 }
-
-
 void turn(double heading, double Kp, double Kd, double Ki, double O, double U) { //turns a certain amount of degrees
 /*New turn code with IMU*/
 double error = heading-IMU.get_rotation();
@@ -97,7 +95,7 @@ void move(double distance, double kP, double kI, double kD) {
     rightVelocity = rightVelocity * 0.01;//how much time passed since last taking of velocity, then multiply by seconds passed to get ticks traveled
     leftVelocity = leftVelocity* 0.01;
     if(abs(IMU.get_heading()) != targetHeading){
-        error = IMU.get_heading() * (kD/70);
+        error = IMU.get_heading() * (kD/40);
     }
     integral = target-distanceT;
     distanceT += ((rightVelocity + leftVelocity)/2.0);//better way to calculate distance traveled?
@@ -105,8 +103,8 @@ void move(double distance, double kP, double kI, double kD) {
     if(integral > 300){
         integral = 300;
     }
-    rightOutput = ((integral)*kI + (error) - (distanceT-distanceT2)*kP);//missing length left in ticks 
-    leftOutput = ((integral)*kI - (error) - ((distanceT-distanceT2)*kP));
+    rightOutput = ((integral)*kI - (error) - (distanceT-distanceT2)*kP);//missing length left in ticks 
+    leftOutput = ((integral)*kI + (error) - ((distanceT-distanceT2)*kP));
     pros::lcd::print(0, "before calling moveRight");
     moveRight(rightOutput);
     pros::lcd::print(0, "after calling moveRight");
@@ -153,8 +151,8 @@ void moveBack(double distance, double kP, double kI, double kD) {
     }
     distanceT -= ((rightVelocity + leftVelocity)/2.0);//better way to calculate distance traveled?
     distanceT2 = -(rightMeasured + leftMeasured)/2.0;
-    rightOutput = ((integral)*kI - (error) - (distanceT-distanceT2)*kP);//missing length left in ticks 
-    leftOutput = ((integral)*kI + (error) - ((distanceT-distanceT2)*kP));
+    rightOutput = ((integral)*kI + (error) - (distanceT-distanceT2)*kP);//missing length left in ticks 
+    leftOutput = ((integral)*kI - (error) - ((distanceT-distanceT2)*kP));
     pros::lcd::print(0, "before calling moveRight");
     moveRight(rightOutput);
     pros::lcd::print(0, "after calling moveRight");
@@ -329,14 +327,6 @@ void putDownArm(){
     Arm.move_velocity(-300);
     pros::delay(1000);
     Arm.move_velocity(0);
-
-}
-void specialMoving(double distance){
-    distance /= 3;
-    Odometry.set_position(0);
-    while(Odometry.get_position() <= 0){
-
-    }
 }
 void intakeMacro(){//for driving
     while(true){
diff --git a/src/auton.cpp b/src/auton.cpp
index 88e2099..1a80d66 100644
--- a/src/auton.cpp
+++ b/src/auton.cpp
@@ -2,6 +2,7 @@
 #include "Functions.h"
 #include "main.h"
 #include "MotorInit.h"
+#include "odom.h"
 void blueRightAWP(){
 	IMU.set_rotation(0);
     Arm.tare_position();
@@ -127,8 +128,7 @@ void blueSRightAWP(){
 	move(45,0.2,0.5,0.2);
 }
 void skills(){
-	turn(180,2.5,0.2,0.1,1,1);
-	/*IMU.set_rotation(0);
+	IMU.set_rotation(0);
 	pros::lcd::print(0,"IMU degrees at the start %f",IMU.get_rotation());
     intake.move_velocity(450);
     pros::delay(500);
@@ -210,9 +210,9 @@ void skills(){
 	pros::delay(50);
 	move(10,0.2,0.3,0.2);
 	pros::delay(50);
-	turn(90,2.5,0.2,0.01,1,1);
+	turn(89,2.5,0.2,0.01,1,1);
 	pros::delay(50);
-	moveBack(78,0.1,0.7,0.5);
+	moveBack(120,0.1,0.1,0);
 	pros::delay(600);
 	clampDown();
 	pros::delay(50);
@@ -275,8 +275,14 @@ void skills(){
 	pros::delay(50);
 	clampRelease();
 	move(10,0.2,0.3,0.2);
-
-
-
-*/
+}
+void specialOdomSkills(){
+	XPos = 0;
+	YPos = 0;
+	//IMU.set_rotation(-90);
+	movePosition(24,12,true);
+	pros::delay(50);
+	movePosition(24,36,false);
+	pros::delay(50);
+	movePosition(48,36,false);
 }
\ No newline at end of file
diff --git a/src/main.cpp b/src/main.cpp
index 705d3b6..0ca22d8 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -12,9 +12,6 @@
  * "I was pressed!" and nothing.
  */
 
-extern double XPos;
-extern double YPos;
-
 void on_center_button() {
 	static bool pressed = false;
 	pressed = !pressed;
@@ -96,7 +93,8 @@ void autonomous() {
 			skills();
 			break;
 }*/
-RedLeftAWP();
+//skills();
+specialOdomSkills();
 }
 
 /**
diff --git a/src/odom.cpp b/src/odom.cpp
index 1fbc1d2..cb7fc40 100644
--- a/src/odom.cpp
+++ b/src/odom.cpp
@@ -3,26 +3,45 @@
 #include "odom.h"
 #include "PIDControls.h"
 
-double XPos;
-double YPos;
+volatile double XPos;
+volatile double YPos;
+double previous;
+double moved = ((RM_MOTOR.get_position() + LM_MOTOR.get_position())/2) / driveTicksPerInch;
 void recordPosition(){//repeatdly call
+IMU.set_rotation(0);
 while(true){
+    moved = (((RM_MOTOR.get_position() + LM_MOTOR.get_position())/2) / driveTicksPerInch) - previous;
     double currenttheta = IMU.get_rotation();
-        XPos +=(cos(currenttheta) * (Odometry.get_position()*(3.1415/180)));
-        YPos += (sin(currenttheta) * (Odometry.get_position()*(3.1415/180)));
-        pros::lcd::print(0,"threading%f", XPos);
-        pros::delay(500);
+    double temp = cos(currenttheta) * moved;
+     if (temp == std::nan("")) {
+        //pros::lcd::print(0,"threading%f, %f",cos(currenttheta), moved);
+        pros::delay(50);
+        continue;
+    }
+       XPos +=(cos(currenttheta)*moved);
+       YPos += (sin(currenttheta) * moved);
+       previous = moved;
+        pros::lcd::print(0,"threading1%f, %f",temp, XPos);
+        pros::delay(50);
 }
 }
 void movePosition(double targetX, double targetY, bool faceBack){
-    double targetTheta = tan((targetY-YPos)/(targetX-XPos));
+    double targetTheta = 180 * atan((targetY-YPos)/(targetX-XPos))/M_PI;
     if(faceBack == true){
-        turn(targetTheta-180, 0.25,0.2,0.1,1,1);
-        moveBack(sqrt(((targetX-XPos)*(targetX-XPos)) - ((targetY-YPos)*(targetY-YPos))),0.2,0.3,0.2);
+        while(abs(targetX - XPos) < 0.1 && abs(targetY - YPos) < 0.1){
+            turn(targetTheta-180, 2.5,0.2,0.1,1,1);
+            pros::delay(100);
+            moveBack(sqrt(((targetX-XPos)*(targetX-XPos)) + ((targetY-YPos)*(targetY-YPos))),0.2,0.3,0.2);
+            pros::delay(100);
+        }
     }
     else{
-        turn(targetTheta, 0.25,0.2,0.1,1,1);
-        move(sqrt(((targetX-XPos)*(targetX-XPos)) - ((targetY-YPos)*(targetY-YPos))),0.2,0.3,0.2);
+        while(abs(targetX - XPos) < 0.1 && abs(targetY - YPos) < 0.1){
+           turn(targetTheta, 2.5,0.2,0.1,1,1);
+           pros::delay(100);
+           move(sqrt(((targetX-XPos)*(targetX-XPos)) + ((targetY-YPos)*(targetY-YPos))),0.2,0.3,0.2);
+           pros::delay(100);
+        }
     }
 }
 void testThread(){
